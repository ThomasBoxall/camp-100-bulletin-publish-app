# Publish Camp 100 Bulletin

from google.oauth2 import service_account
from googleapiclient.discovery import build
from google.cloud import logging as cloud_logging
from google.cloud.logging.handlers import CloudLoggingHandler
import functions_framework


import requests
import base64
import yaml
import logging
import sys
import io
import re
import datetime
import json

# DECLARE CONSTANTS

# INITIALISE CONSTANTS TO BE POPULATED BY CONFIG FILE
GS_SPREADSHEET_ID = ""
GS_SPREADSHEET_SHEET_NAME = ""

GA_SERVICE_ACCOUNT_CREDS_PATH = ""
GA_SERVICE_ACCOUNT_PROJECT_ID = ""
GA_SCOPES = []

WP_USERNAME = ""
WP_APPLICATION_PASSWORD = ""
WP_SITE_URL = ""

DIS_GENERAL_NOTIF_WEBHOOK = ""
DIS_ADMIN_NOTIF_WEBHOOK = ""

APPL_NAME = ""
APPL_ENV = ""

# Initialise global variables
numberOfEntriesInBulletin = 0

# INITIALISE LOGGING

# SETUP LOGGING LOCAL BUFFER
log_buffer = io.StringIO()
bufferLoggingHandler = logging.StreamHandler(log_buffer)
bufferLoggingFormat = logging.Formatter('[BUFF] %(asctime)s - %(levelname)s - %(message)s')
bufferLoggingHandler.setFormatter(bufferLoggingFormat)

# Get the root logger and add the buffer handler
rootLoggingHandler = logging.getLogger()
rootLoggingHandler.setLevel(logging.INFO) # Set a default level (adjust as needed)
rootLoggingHandler.addHandler(bufferLoggingHandler)

consoleLoggingFormat = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
consoleLoggingHandler = logging.StreamHandler()
consoleLoggingHandler.setFormatter(consoleLoggingFormat)
rootLoggingHandler.addHandler(consoleLoggingHandler)


# Regex to parse the log line generated by our formatter
# This assumes the format: 'YYYY-MM-DD HH:MM:SS,ms - LEVELNAME - LOGGER_NAME - ENV - MESSAGE'
LOG_PARSE_REGEX = re.compile(
    r"^(?P<timestamp>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}) "
    r"- (?P<levelname>[A-Z]+) "
    r"- (?P<name>[\w.]+) "
    r"- (?P<env>[\w.]+) "
    r"- (?P<message>.*)$"
)

# Severity mapping for Cloud Logging
SEVERITY_MAP = {
    'DEBUG': 'DEBUG',
    'INFO': 'INFO',
    'WARNING': 'WARNING',
    'ERROR': 'ERROR',
    'CRITICAL': 'CRITICAL'
}

# some voodoo magic used here because we need to attach the cloud logging, after writing log entries because of reading service account credentials from file & wanting to log that!
# code produced by Gemini. No clue how or why it works but it seems to

def setupCloudLogging(credentials_path: str, project_id: str):
    rootLoggingHandler.info("Attempting to set up Google Cloud Logging...") # This log goes to buffer for now

    try:
        credentials = service_account.Credentials.from_service_account_file(credentials_path)
        client = cloud_logging.Client(
            project=project_id,
            credentials=credentials
        )

        # Parse through buffered log entries and prepare them for logging to the Cloud Logger
        buffered_logs_string = log_buffer.getvalue()
        if buffered_logs_string:
            rootLoggingHandler.info("Flushing previously buffered logs to Google Cloud Logging (chronologically)...")
            logName = f"{APPL_NAME}{APPL_ENV}"
            logger_cloud = client.logger(logName) # Get a logger object for manual logging

            for line in buffered_logs_string.splitlines():
                if not line.strip():
                    continue

                match = LOG_PARSE_REGEX.match(line)
                if match:
                    log_data = match.groupdict()
                    # Parse timestamp from string to datetime object
                    timestamp_str = log_data['timestamp'].replace(',', '.') # Convert 'ms' comma to dot for parsing
                    timestamp_dt = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S.%f')

                    # Prepare struct for Cloud Logging, includes original fields
                    log_entry_struct = {
                        "message": log_data['message'],
                        "severity": SEVERITY_MAP.get(log_data['levelname'], 'DEFAULT'),
                        "source_logger": log_data['name'],
                        "environment": log_data['env'],
                        # Add any other fields you want to extract and log as structured data
                    }
                    
                    # Manually log the text payload and structure with the original timestamp
                    logger_cloud.log_struct(
                        log_entry_struct,
                        timestamp=timestamp_dt,
                        severity=SEVERITY_MAP.get(log_data['levelname'], 'DEFAULT') # Ensure severity is also set
                    )
                else:
                    # If parsing fails, just log the raw line as INFO
                    logger_cloud.log_text(line, severity='INFO')

            rootLoggingHandler.info("Buffered logs flushed to Cloud Logging.")
        else:
            rootLoggingHandler.info("No logs were buffered before Cloud Logging setup.")


        # attach the CloudLoggingHandler for future logs
        cloudLoggingHandler = CloudLoggingHandler(client=client, name=logName)
        cloudLoggingFormat = logging.Formatter(f'{APPL_NAME} {APPL_ENV} %(asctime)s - %(levelname)s - %(message)s')
        cloudLoggingHandler.setFormatter(cloudLoggingFormat)

        rootLoggingHandler.removeHandler(bufferLoggingHandler)
        rootLoggingHandler.removeHandler(consoleLoggingHandler)
        rootLoggingHandler.addHandler(consoleLoggingHandler)
        rootLoggingHandler.addHandler(cloudLoggingHandler)

        rootLoggingHandler.info("Google Cloud Logging handler attached for future logs.")


    except Exception as e:
        # If Cloud Logging setup fails, ensure local logging remains active
        rootLoggingHandler.error(f"Failed to set up Google Cloud Logging: {e}")
        # Make sure console handler is still attached if Cloud Logging fails
        rootLoggingHandler.addHandler(consoleLoggingHandler)
        rootLoggingHandler.info("Continuing with local logging due to Cloud Logging setup failure.")


def initialise():
    """
    Initialises the program: sets global variables
    """

    logging.info("begin initialising")

    global GS_SPREADSHEET_ID, GS_SPREADSHEET_SHEET_NAME, GA_SERVICE_ACCOUNT_CREDS_PATH, GA_SERVICE_ACCOUNT_PROJECT_ID, GA_SCOPES, WP_USERNAME, WP_APPLICATION_PASSWORD, DIS_GENERAL_NOTIF_WEBHOOK, DIS_ADMIN_NOTIF_WEBHOOK, WP_SITE_URL, APPL_ENV, APPL_NAME

    try:
        with open('config.yml', 'r') as configYml:
            logging.info("opened config file")
            configData = yaml.safe_load(configYml)
    except FileNotFoundError as fnfError:
            logging.error('file not found')
            sys.exit()
    
    # we have found the file so crack on and read it
    try:
        GS_SPREADSHEET_ID = configData['google-sheets']['spreadsheet-id']
        GS_SPREADSHEET_SHEET_NAME = configData['google-sheets']['spreadsheet-sheet-name']

        GA_SERVICE_ACCOUNT_CREDS_PATH = configData['google-auth']['service-account-creds-path']
        GA_SERVICE_ACCOUNT_PROJECT_ID = configData['google-auth']['service-account-project-id']
        GA_SCOPES = configData['google-auth']['auth-scopes']

        WP_USERNAME = configData['wordpress']['username']
        WP_APPLICATION_PASSWORD = configData['wordpress']['application-password']
        WP_SITE_URL = configData['wordpress']['site-url']

        DIS_GENERAL_NOTIF_WEBHOOK = configData['discord']['general-notif-webhook']
        DIS_ADMIN_NOTIF_WEBHOOK = configData['discord']['admin-notif-webhook']

        APPL_NAME = configData['application']['name']
        APPL_ENV = configData['application']['environment']

        logging.info("successfully parsed all config data")

    except Exception as e:
        postToDiscord('admin', f"ðŸš¨ **Critical Error**: Failed to parse config file with error {e}")
        logging.critical(f"parsing config data into global constants: {e}")

    logging.info("complete initialisation")


def main():
    logging.info("starting main execution")

    logging.info("starting google credentials validation")

    try:
        ga_creds = None
        ga_creds = service_account.Credentials.from_service_account_file(
                                    filename=GA_SERVICE_ACCOUNT_CREDS_PATH, 
                                    scopes=GA_SCOPES)

    except Exception as e:
        postToDiscord('admin' f'failed to build service account: {e}')
        logging.critical(f"failed to build service account: {e}")

    logging.info("creds validated")

    logging.info("beginning sheet fetch")

    try:
        gs_service = build('sheets', 'v4', credentials=ga_creds)

        result = gs_service.spreadsheets().values().get(
            spreadsheetId=GS_SPREADSHEET_ID, range=GS_SPREADSHEET_SHEET_NAME).execute()
        values = result.get('values', [])
    except Exception as e:
        logging.critical(f"Error consuming Google Sheet: {e}")

    try:
        if not values or len(values) == 1:
            # if spreadsheet is completely entry or there is just the header row: something's gone wrong...
            logging.info("no data in spreadsheet")
            postToDiscord('general', f'ðŸš¨ **ERROR** No data found in Google Sheet. Bulletin not published.')
        else:
            print('Data from Google Sheet:')
            for row in values:
                logging.debug(f"row: {row}")
            logging.info(f'Successfully read {len(values)} rows from Google Sheet')

            wpPostTitle = generateWPPostTitle()
            wpPostContent = buildWPPostContent(values)
            wpPostSlug = generateWPPostSlug()

            if numberOfEntriesInBulletin == 0:
                # no valid entires in the bulletin, so don't publish (ie nothing with flag set)
                postToDiscord('general', f'ðŸš¨ **ERROR** No valid entries found in Google Sheet. Bulletin not published.')
            else:
                # valid bulletin as num entries >= 1
                postToWP(wpPostTitle, wpPostContent, wpPostSlug)

                
    
    except Exception as e:
        logging.critical(f"error parsing spreadsheet response: {e}")

def generateWPPostTitle() -> str:
    """
    Generates suitable title for WordPress post based on the rounded current time
    """

    currentDateTime = datetime.datetime.now()
    formattedCurrentDateTime = roundToNearestHalfHour(currentDateTime).strftime("%H:%M, %A %d %B")

    postTitle = f"Camp 100 Bulletin ({formattedCurrentDateTime})"

    logging.info(f"generated post title: {postTitle}")

    return postTitle

def generateWPPostSlug() -> str:
    """
    Generates suitable slug for WordPress post based on the rounded current time
    """
    
    currentDateTime = datetime.datetime.now()
    formattedCurrentDateTime = roundToNearestHalfHour(currentDateTime).strftime("%m%d-%H%M")

    postSlug = f"bulletin-{formattedCurrentDateTime}"

    logging.info(f"generated post slug: {postSlug}")

    return postSlug

def roundToNearestHalfHour(dt: datetime.datetime) -> datetime.datetime:
    """
    Rounds the current time to the nearest half hour
    """

    # Calculate the number of minutes past the hour
    minutes = dt.minute

    # Calculate target seconds (either 0 or 1800) based on which half of the hour we are in
    if minutes < 15:  # Closer to 00
        rounded_dt = dt.replace(minute=0, second=0, microsecond=0)
    elif minutes >= 15 and minutes < 45: # Closer to 30
        rounded_dt = dt.replace(minute=30, second=0, microsecond=0)
    else:  # Closer to next 00 (next hour)
        rounded_dt = (dt + datetime.timedelta(hours=1)).replace(minute=0, second=0, microsecond=0)
        
    return rounded_dt
        
def buildWPPostContent(responseContent: str) -> str:
    """
    Builds WordPress Post content based on provided `content`
    """

    global numberOfEntriesInBulletin

    wpPost = f"<p>Published at {datetime.datetime.now()}</p>"
    validEntries = 0
    # delete the header from the spreadsheet
    del responseContent[0]

    # sort the responses by their includeFlag so there is some control over which order they are included in
    responseContent = sorted(responseContent, key=lambda x: x[0])

    for oneRecord in responseContent:
        try:
            if oneRecord[0] in ['1', '2', '3']:
                # to be included
                oneRecordText = f"<h3>{oneRecord[2]}</h3><p>{oneRecord[3]}</p><p>From: {oneRecord[4]}</p>"
                wpPost += oneRecordText
                validEntries += 1
        except Exception as e:
            logging.error(f"bad bulletin entry. content {oneRecord}. error: {e}")
    
    logging.info(f"generated WP post body. {validEntries} posts included")

    numberOfEntriesInBulletin = validEntries
    
    logging.info(wpPost)
    return wpPost

def postToWP(title: str, content: str, slug: str):
    """
    Posts provided post to WordPress 
    """

    try:
        # build WP credentials 
        wp_credentials = f"{WP_USERNAME}:{WP_APPLICATION_PASSWORD}"
        wp_token = base64.b64encode(wp_credentials.encode()).decode('utf-8')

        wp_headers = {
            'Authorization': f'Basic {wp_token}',
            'Content-Type': 'application/json'
        }

        api_url = f"{WP_SITE_URL}/wp-json/wp/v2/posts"
        data = {
        'title' : title,
        'status' : 'publish',
        'slug' : slug,
        'content' : content
        }

        # we have a post ready to go so make request to WordPress 

        try:
            response = requests.post(api_url,headers=wp_headers, json=data)
            if response.status_code == 201:
                # success
                logging.info(f"published to wordpress with return code {response}")
                postToDiscord('general', f'ðŸ“£ **POSTED** New Bulletin posted containing {numberOfEntriesInBulletin} entries. {WP_SITE_URL}/{slug}')
            else:
                # error
                logging.critical(f"failed to post to WordPress with return code: {response.status_code}")
                postToDiscord('general', f'ðŸš¨ **ERROR** Failed to post to WordPress due to Technical Error. Bulletin not published')
                postToDiscord('admin', f'Failed to post to WordPress with response {response}')

        except Exception as wpe:
            postToDiscord('admin', f"failed to publish to WP: {wpe}")
            logging.critical(f"failed to publish to wordpress. {wpe}")

    except Exception as e:
        postToDiscord('admin', f"failed to build WP service: {e}")
        postToDiscord('general', f"ðŸš¨ **ERROR** Failed to post to WordPress due to failing to construct WordPress Service. Bulletin Not Published")
        logging.critical(f"failed to build WP service. {e}")

def postToDiscord(mode: str, content: str):
    """
    Posts to Discord either in admin or general mode
    """
    postToUrl = ""
    body = {}
    
    # match case block to set body
    match mode:
        case 'general':
            postToUrl = DIS_GENERAL_NOTIF_WEBHOOK
            body = {
                "content": content,
                "username": f"{APPL_NAME}-{APPL_ENV} Notifier"
            }
        case 'admin':
            postToUrl = DIS_ADMIN_NOTIF_WEBHOOK
            body = {
                "content": content,
                "username": f"{APPL_NAME}-{APPL_ENV} ADMIN Notifier"
            }
        case default:
            logging.error(f"invalid mode passed to postToDiscord: {mode}")
    
    logging.info(f"constructed discord webhook post: {body}")
    logging.info(f"discord webhook targeting: {postToUrl}")

    try:
        discordResult = requests.post(postToUrl, json=body)
        logging.info(f"discord posted: {discordResult}")
    except Exception as e:
        logging.critical(f"returned error from discord: {e}")
    
@functions_framework.cloud_event
def cloudHandler(launchContext):
    logging.info(launchContext)
    logging.info("--- APPLICAITON STARTUP ---")
    initialise()
    setupCloudLogging(GA_SERVICE_ACCOUNT_CREDS_PATH, GA_SERVICE_ACCOUNT_PROJECT_ID)
    main()
    logging.info("--- APPLICATION TERMINATION ---")
    return ("complete", 200)

